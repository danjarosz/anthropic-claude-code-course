import { anthropic } from "@ai-sdk/anthropic";
import {
  LanguageModelV3,
  LanguageModelV3CallOptions,
  LanguageModelV3StreamPart,
  LanguageModelV3Prompt,
  LanguageModelV3Content,
  LanguageModelV3FinishReason,
} from "@ai-sdk/provider";

const MODEL = "claude-haiku-4-5";

export class MockLanguageModel implements LanguageModelV3 {
  readonly specificationVersion = "v3" as const;
  readonly provider = "mock";
  readonly modelId: string;
  readonly defaultObjectGenerationMode = "tool" as const;

  constructor(modelId: string) {
    this.modelId = modelId;
  }

  get supportedUrls() {
    return {};
  }

  private async delay(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  private extractUserPrompt(prompt: LanguageModelV3Prompt): string {
    // Find the last user message
    for (let i = prompt.length - 1; i >= 0; i--) {
      const message = prompt[i];
      if (message.role === "user") {
        const content = message.content;
        if (Array.isArray(content)) {
          // Extract text from content parts
          const textParts = content
            .filter((part: any) => part.type === "text")
            .map((part: any) => part.text);
          return textParts.join(" ");
        } else if (typeof content === "string") {
          return content;
        }
      }
    }
    return "";
  }

  private getLastToolResult(prompt: LanguageModelV3Prompt): any {
    // Find the last tool message
    for (let i = prompt.length - 1; i >= 0; i--) {
      if (prompt[i].role === "tool") {
        const content = prompt[i].content;
        if (Array.isArray(content) && content.length > 0) {
          return content[0];
        }
      }
    }
    return null;
  }

  private textIdCounter = 0;
  private toolIdCounter = 0;

  private async *generateMockStream(
    prompt: LanguageModelV3Prompt,
    userPrompt: string
  ): AsyncGenerator<LanguageModelV3StreamPart> {
    // Count tool messages to determine which step we're on
    const toolMessageCount = prompt.filter((m) => m.role === "tool").length;

    // Determine component type from the original user prompt
    const promptLower = userPrompt.toLowerCase();
    let componentType = "counter";
    let componentName = "Counter";

    if (promptLower.includes("form")) {
      componentType = "form";
      componentName = "ContactForm";
    } else if (promptLower.includes("card")) {
      componentType = "card";
      componentName = "Card";
    }

    // Helper to yield text with proper V3 format
    const yieldText = async function* (self: MockLanguageModel, text: string, delayMs: number) {
      const textId = `text-${++self.textIdCounter}`;
      yield { type: "text-start" as const, id: textId };
      for (const char of text) {
        yield { type: "text-delta" as const, id: textId, delta: char };
        await self.delay(delayMs);
      }
      yield { type: "text-end" as const, id: textId };
    };

    // Helper to yield tool call with proper V3 format
    const yieldToolCall = function* (self: MockLanguageModel, toolName: string, args: any) {
      const toolId = `tool-${++self.toolIdCounter}`;
      yield {
        type: "tool-input-start" as const,
        id: toolId,
        toolName,
      };
      yield {
        type: "tool-input-delta" as const,
        id: toolId,
        delta: JSON.stringify(args),
      };
      yield {
        type: "tool-input-end" as const,
        id: toolId,
      };
    };

    // Step 1: Create component file
    if (toolMessageCount === 1) {
      yield* yieldText(this, `I'll create a ${componentName} component for you.`, 25);
      yield* yieldToolCall(this, "str_replace_editor", {
        command: "create",
        path: `/components/${componentName}.jsx`,
        file_text: this.getComponentCode(componentType),
      });
      yield {
        type: "finish",
        finishReason: { unified: "tool-calls" as const, raw: undefined },
        usage: { inputTokens: { total: 50, noCache: undefined, cacheRead: undefined, cacheWrite: undefined }, outputTokens: { total: 30, text: undefined, reasoning: undefined } },
      };
      return;
    }

    // Step 2: Enhance component
    if (toolMessageCount === 2) {
      yield* yieldText(this, `Now let me enhance the component with better styling.`, 25);
      yield* yieldToolCall(this, "str_replace_editor", {
        command: "str_replace",
        path: `/components/${componentName}.jsx`,
        old_str: this.getOldStringForReplace(componentType),
        new_str: this.getNewStringForReplace(componentType),
      });
      yield {
        type: "finish",
        finishReason: { unified: "tool-calls" as const, raw: undefined },
        usage: { inputTokens: { total: 50, noCache: undefined, cacheRead: undefined, cacheWrite: undefined }, outputTokens: { total: 30, text: undefined, reasoning: undefined } },
      };
      return;
    }

    // Step 3: Create App.jsx
    if (toolMessageCount === 0) {
      yield* yieldText(this, `This is a static response. You can place an Anthropic API key in the .env file to use the Anthropic API for component generation. Let me create an App.jsx file to display the component.`, 15);
      yield* yieldToolCall(this, "str_replace_editor", {
        command: "create",
        path: "/App.jsx",
        file_text: this.getAppCode(componentName),
      });
      yield {
        type: "finish",
        finishReason: { unified: "tool-calls" as const, raw: undefined },
        usage: { inputTokens: { total: 50, noCache: undefined, cacheRead: undefined, cacheWrite: undefined }, outputTokens: { total: 30, text: undefined, reasoning: undefined } },
      };
      return;
    }

    // Step 4: Final summary (no tool call)
    if (toolMessageCount >= 3) {
      yield* yieldText(this, `Perfect! I've created:

1. **${componentName}.jsx** - A fully-featured ${componentType} component
2. **App.jsx** - The main app file that displays the component

The component is now ready to use. You can see the preview on the right side of the screen.`, 30);
      yield {
        type: "finish",
        finishReason: { unified: "stop" as const, raw: undefined },
        usage: { inputTokens: { total: 50, noCache: undefined, cacheRead: undefined, cacheWrite: undefined }, outputTokens: { total: 50, text: undefined, reasoning: undefined } },
      };
      return;
    }
  }

  private getComponentCode(componentType: string): string {
    switch (componentType) {
      case "form":
        return `import React, { useState } from 'react';

const ContactForm = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form submitted:', formData);
    // Handle form submission here
  };

  return (
    <div className="max-w-md mx-auto p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-6">Contact Us</h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="name" className="block text-sm font-medium text-gray-700 mb-1">
            Name
          </label>
          <input
            type="text"
            id="name"
            name="name"
            value={formData.name}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700 mb-1">
            Email
          </label>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <div>
          <label htmlFor="message" className="block text-sm font-medium text-gray-700 mb-1">
            Message
          </label>
          <textarea
            id="message"
            name="message"
            value={formData.message}
            onChange={handleChange}
            required
            rows={4}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <button
          type="submit"
          className="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 transition-colors"
        >
          Send Message
        </button>
      </form>
    </div>
  );
};

export default ContactForm;`;

      case "card":
        return `import React from 'react';

const Card = ({ 
  title = "Welcome to Our Service", 
  description = "Discover amazing features and capabilities that will transform your experience.",
  imageUrl,
  actions 
}) => {
  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden">
      {imageUrl && (
        <img 
          src={imageUrl} 
          alt={title}
          className="w-full h-48 object-cover"
        />
      )}
      <div className="p-6">
        <h3 className="text-xl font-semibold mb-2">{title}</h3>
        <p className="text-gray-600 mb-4">{description}</p>
        {actions && (
          <div className="mt-4">
            {actions}
          </div>
        )}
      </div>
    </div>
  );
};

export default Card;`;

      default:
        return `import { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  const decrement = () => {
    setCount(count - 1);
  };

  const reset = () => {
    setCount(0);
  };

  return (
    <div className="flex flex-col items-center p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-4">Counter</h2>
      <div className="text-4xl font-bold mb-6">{count}</div>
      <div className="flex gap-4">
        <button 
          onClick={decrement}
          className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors"
        >
          Decrease
        </button>
        <button 
          onClick={reset}
          className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
        >
          Reset
        </button>
        <button 
          onClick={increment}
          className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors"
        >
          Increase
        </button>
      </div>
    </div>
  );
};

export default Counter;`;
    }
  }

  private getOldStringForReplace(componentType: string): string {
    switch (componentType) {
      case "form":
        return "    console.log('Form submitted:', formData);";
      case "card":
        return '      <div className="p-6">';
      default:
        return "  const increment = () => setCount(count + 1);";
    }
  }

  private getNewStringForReplace(componentType: string): string {
    switch (componentType) {
      case "form":
        return "    console.log('Form submitted:', formData);\n    alert('Thank you! We\\'ll get back to you soon.');";
      case "card":
        return '      <div className="p-6 hover:bg-gray-50 transition-colors">';
      default:
        return "  const increment = () => setCount(prev => prev + 1);";
    }
  }

  private getAppCode(componentName: string): string {
    if (componentName === "Card") {
      return `import Card from '@/components/Card';

export default function App() {
  return (
    <div className="min-h-screen bg-gray-100 flex items-center justify-center p-8">
      <div className="w-full max-w-md">
        <Card 
          title="Amazing Product"
          description="This is a fantastic product that will change your life. Experience the difference today!"
          actions={
            <button className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition-colors">
              Learn More
            </button>
          }
        />
      </div>
    </div>
  );
}`;
    }

    return `import ${componentName} from '@/components/${componentName}';

export default function App() {
  return (
    <div className="min-h-screen bg-gray-100 flex items-center justify-center p-8">
      <div className="w-full max-w-md">
        <${componentName} />
      </div>
    </div>
  );
}`;
  }

  async doGenerate(options: LanguageModelV3CallOptions) {
    const userPrompt = this.extractUserPrompt(options.prompt);

    // Collect all stream parts
    const parts: LanguageModelV3StreamPart[] = [];
    for await (const part of this.generateMockStream(
      options.prompt,
      userPrompt
    )) {
      parts.push(part);
    }

    // Build content from parts
    const content: LanguageModelV3Content[] = [];

    const textParts = parts
      .filter((p) => p.type === "text-delta")
      .map((p) => (p as any).delta)
      .join("");

    if (textParts) {
      content.push({ type: "text", text: textParts });
    }

    // Collect tool calls from start/delta/end parts
    const toolInputStarts = parts.filter((p) => p.type === "tool-input-start");
    const toolInputDeltas = parts.filter((p) => p.type === "tool-input-delta");

    for (const start of toolInputStarts) {
      const delta = toolInputDeltas.find((d: any) => d.id === (start as any).id) as any;
      content.push({
        type: "tool-call",
        toolCallId: (start as any).id,
        toolName: (start as any).toolName,
        input: delta?.delta || "{}",
      });
    }

    // Get finish reason from finish part
    const finishPart = parts.find((p) => p.type === "finish") as any;
    const finishReason: LanguageModelV3FinishReason =
      finishPart?.finishReason?.unified === "tool-calls"
        ? { unified: "tool-calls", raw: undefined }
        : { unified: "stop", raw: undefined };

    return {
      content,
      finishReason,
      usage: {
        inputTokens: {
          total: 100,
          noCache: undefined,
          cacheRead: undefined,
          cacheWrite: undefined,
        },
        outputTokens: {
          total: 200,
          text: undefined,
          reasoning: undefined,
        },
      },
      warnings: [],
      request: { body: options.prompt },
      response: { body: {} },
    };
  }

  async doStream(
    options: LanguageModelV3CallOptions
  ): Promise<{
    stream: ReadableStream<LanguageModelV3StreamPart>;
    warnings: any[];
  }> {
    const userPrompt = this.extractUserPrompt(options.prompt);
    const self = this;

    const stream = new ReadableStream<LanguageModelV3StreamPart>({
      async start(controller) {
        try {
          const generator = self.generateMockStream(options.prompt, userPrompt);
          for await (const chunk of generator) {
            controller.enqueue(chunk);
          }
          controller.close();
        } catch (error) {
          controller.error(error);
        }
      },
    });

    return {
      stream,
      warnings: [],
    };
  }
}

export function getLanguageModel() {
  const apiKey = process.env.ANTHROPIC_API_KEY;

  if (!apiKey || apiKey.trim() === "") {
    console.log("No ANTHROPIC_API_KEY found, using mock provider");
    return new MockLanguageModel("mock-claude-sonnet-4-0");
  }

  return anthropic(MODEL);
}
